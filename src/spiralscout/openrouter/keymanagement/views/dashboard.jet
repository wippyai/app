{{ extends "/common/layout" }}

{{ block title() }}OpenRouter Key Management{{ end }}
{{ block metaDescription() }}Manage OpenRouter API keys with bulk creation, disable/enable, and balance monitoring{{ end }}

{{ block mainContent() }}
<div x-data="openRouterApp" x-init="init()" class="max-w-7xl mx-auto">
    <!-- Header -->
    <div class="mb-8">
        <div class="flex items-center justify-between">
            <div class="flex items-center">
                <div class="h-14 w-14 rounded-2xl bg-gradient-to-br from-primary-500 to-primary-600 flex items-center justify-center shadow-lg">
                    <iconify-icon icon="tabler:key" class="text-white" width="28" height="28"></iconify-icon>
                </div>
                <div class="ml-5">
                    <h1 class="text-2xl font-bold text-surface-900 dark:text-surface-100">OpenRouter Key Management</h1>
                    <p class="mt-1 text-surface-600 dark:text-surface-400">Create and manage API keys with credit limits and balance monitoring</p>
                </div>
            </div>

            <div class="flex items-center space-x-4">
                <button
                        @click="exportCSV"
                        :disabled="keys.length === 0"
                        class="flex items-center px-4 py-2.5 bg-surface-100 dark:bg-surface-800 hover:bg-surface-200 dark:hover:bg-surface-700 text-surface-700 dark:text-surface-300 rounded-xl border border-surface-200 dark:border-surface-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                    <iconify-icon icon="tabler:download" class="mr-2" width="18" height="18"></iconify-icon>
                    Export CSV
                </button>
            </div>
        </div>
    </div>

    <!-- Bulk Creation Form -->
    <div class="mb-8 bg-white dark:bg-surface-800 rounded-2xl shadow-sm border border-surface-200 dark:border-surface-700 overflow-hidden">
        <div class="px-6 py-5 border-b border-surface-200 dark:border-surface-700">
            <h3 class="text-lg font-semibold text-surface-900 dark:text-surface-100">Bulk Key Creation</h3>
            <p class="mt-1 text-surface-600 dark:text-surface-400">Create multiple API keys with specified credit limits</p>
        </div>

        <div class="p-6">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Email Input -->
                <div class="lg:col-span-2">
                    <label for="emails" class="block text-sm font-medium text-surface-700 dark:text-surface-300 mb-2">
                        Email Addresses <span class="text-red-500">*</span>
                    </label>
                    <textarea
                            id="emails"
                            x-model="form.emails"
                            placeholder="Enter email addresses (one per line)&#10;user1@example.com&#10;user2@example.com&#10;user3@example.com"
                            rows="4"
                            class="w-full px-3 py-2 border border-surface-300 dark:border-surface-600 rounded-xl bg-white dark:bg-surface-700 text-surface-900 dark:text-surface-100 placeholder-surface-500 dark:placeholder-surface-400 focus:ring-2 focus:ring-primary-500 focus:border-transparent transition-all"></textarea>
                    <p class="mt-2 text-xs text-surface-500 dark:text-surface-400">
                        <span x-text="emailCount"></span> email(s) detected
                    </p>
                </div>

                <!-- Credit Limit and Actions -->
                <div class="space-y-4">
                    <div>
                        <label for="creditLimit" class="block text-sm font-medium text-surface-700 dark:text-surface-300 mb-2">
                            Credit Limit (USD) <span class="text-red-500">*</span>
                        </label>
                        <input
                                type="number"
                                id="creditLimit"
                                x-model="form.creditLimit"
                                min="0"
                                step="0.01"
                                placeholder="10.00"
                                class="w-full px-3 py-2 border border-surface-300 dark:border-surface-600 rounded-xl bg-white dark:bg-surface-700 text-surface-900 dark:text-surface-100 placeholder-surface-500 dark:placeholder-surface-400 focus:ring-2 focus:ring-primary-500 focus:border-transparent transition-all">
                        <p class="mt-2 text-xs text-surface-500 dark:text-surface-400">
                            Initial credit limit for all created keys
                        </p>
                    </div>

                    <!-- Create Button -->
                    <button
                            @click="createKeys"
                            :disabled="loading.create || !canCreate"
                            class="w-full flex items-center justify-center px-6 py-3 bg-gradient-to-r from-primary-600 to-primary-700 hover:from-primary-700 hover:to-primary-800 text-white rounded-xl font-semibold shadow-md hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200">
                        <iconify-icon x-show="!loading.create" icon="tabler:plus" class="mr-2" width="18" height="18"></iconify-icon>
                        <iconify-icon x-show="loading.create" icon="tabler:loader-2" class="mr-2 animate-spin" width="18" height="18"></iconify-icon>
                        <span x-text="loading.create ? 'Creating...' : 'Create Keys'"></span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Keys Table -->
    <div class="bg-white dark:bg-surface-800 rounded-2xl shadow-sm border border-surface-200 dark:border-surface-700 overflow-hidden">
        <div class="px-6 py-5 border-b border-surface-200 dark:border-surface-700">
            <div class="flex items-center justify-between">
                <div>
                    <h3 class="text-lg font-semibold text-surface-900 dark:text-surface-100">API Keys</h3>
                    <p class="mt-1 text-surface-600 dark:text-surface-400">
                        <span x-text="keys.length"></span> total keys
                    </p>
                </div>
                <div class="flex items-center space-x-3">
                    <button
                            @click="checkAllBalances"
                            :disabled="loading.balanceAll || keys.length === 0"
                            class="flex items-center px-4 py-2.5 bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 text-white rounded-xl font-medium shadow-sm hover:shadow-md disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200">
                        <iconify-icon x-show="!loading.balanceAll" icon="tabler:refresh" class="mr-2" width="16" height="16"></iconify-icon>
                        <iconify-icon x-show="loading.balanceAll" icon="tabler:loader-2" class="mr-2 animate-spin" width="16" height="16"></iconify-icon>
                        <span x-text="loading.balanceAll ? 'Checking...' : 'Check All Balances'"></span>
                    </button>
                    <button
                            @click="loadKeys"
                            :disabled="loading.list"
                            class="flex items-center px-4 py-2.5 bg-surface-100 dark:bg-surface-700 hover:bg-surface-200 dark:hover:bg-surface-600 text-surface-700 dark:text-surface-300 rounded-xl font-medium border border-surface-200 dark:border-surface-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                        <iconify-icon :class="{'animate-spin': loading.list}" icon="tabler:refresh" class="mr-2" width="16" height="16"></iconify-icon>
                        Refresh
                    </button>
                </div>
            </div>
        </div>

        <!-- Loading State -->
        <div x-show="loading.list && keys.length === 0" class="text-center py-16">
            <div class="mx-auto h-16 w-16 rounded-2xl bg-surface-100 dark:bg-surface-700 flex items-center justify-center mb-6">
                <iconify-icon icon="tabler:loader-2" class="text-surface-400 dark:text-surface-500 animate-spin" width="32" height="32"></iconify-icon>
            </div>
            <h3 class="text-xl font-semibold text-surface-900 dark:text-surface-100 mb-2">Loading keys...</h3>
            <p class="text-surface-600 dark:text-surface-400">Please wait while we fetch your API keys</p>
        </div>

        <!-- Empty State -->
        <div x-show="!loading.list && keys.length === 0" class="text-center py-16">
            <div class="mx-auto h-16 w-16 rounded-2xl bg-surface-100 dark:bg-surface-700 flex items-center justify-center mb-6">
                <iconify-icon icon="tabler:key-off" class="text-surface-400 dark:text-surface-500" width="32" height="32"></iconify-icon>
            </div>
            <h3 class="text-xl font-semibold text-surface-900 dark:text-surface-100 mb-2">No API keys found</h3>
            <p class="text-surface-600 dark:text-surface-400 mb-6">Create your first set of OpenRouter API keys using the form above.</p>
        </div>

        <!-- Keys Table -->
        <div x-show="!loading.list && keys.length > 0" class="overflow-x-auto">
            <table class="min-w-full divide-y divide-surface-200 dark:divide-surface-700">
                <thead class="bg-surface-50 dark:bg-surface-900/50">
                <tr>
                    <th class="px-6 py-4 text-left text-xs font-medium text-surface-500 dark:text-surface-400 uppercase tracking-wider">Email</th>
                    <th class="px-6 py-4 text-left text-xs font-medium text-surface-500 dark:text-surface-400 uppercase tracking-wider">API Key</th>
                    <th class="px-6 py-4 text-left text-xs font-medium text-surface-500 dark:text-surface-400 uppercase tracking-wider">Credit Limit</th>
                    <th class="px-6 py-4 text-left text-xs font-medium text-surface-500 dark:text-surface-400 uppercase tracking-wider">Balance</th>
                    <th class="px-6 py-4 text-left text-xs font-medium text-surface-500 dark:text-surface-400 uppercase tracking-wider">Status</th>
                    <th class="px-6 py-4 text-left text-xs font-medium text-surface-500 dark:text-surface-400 uppercase tracking-wider">Created</th>
                    <th class="px-6 py-4 text-left text-xs font-medium text-surface-500 dark:text-surface-400 uppercase tracking-wider">Actions</th>
                </tr>
                </thead>
                <tbody class="bg-white dark:bg-surface-800 divide-y divide-surface-200 dark:divide-surface-700">
                <template x-for="key in keys" :key="key.key_id">
                    <tr class="hover:bg-surface-50 dark:hover:bg-surface-700/50 transition-colors group">
                        <!-- Email -->
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-surface-900 dark:text-surface-100" x-text="key.email"></td>

                        <!-- API Key -->
                        <td class="px-6 py-4 whitespace-nowrap">
                            <div class="flex items-center space-x-2">
                                <code class="text-xs font-mono text-surface-800 dark:text-surface-200 bg-surface-100 dark:bg-surface-700 px-2 py-1 rounded-lg max-w-32 truncate block"
                                      x-text="formatKeyDisplay(key.key_value)"
                                      :title="key.key_value"></code>
                                <button
                                        @click="copyToClipboard(key.key_value)"
                                        class="p-1.5 text-surface-400 hover:text-surface-600 dark:hover:text-surface-300 hover:bg-surface-100 dark:hover:bg-surface-600 rounded-lg transition-colors">
                                    <iconify-icon icon="tabler:copy" width="14" height="14"></iconify-icon>
                                </button>
                            </div>
                        </td>

                        <!-- Credit Limit -->
                        <td class="px-6 py-4 whitespace-nowrap">
                            <div x-show="editingLimit !== key.key_id" class="flex items-center space-x-2">
                                <span class="text-sm text-surface-900 dark:text-surface-100" x-text="'$' + parseFloat(key.credit_limit).toFixed(2)"></span>
                                <button
                                        @click="startEditLimit(key)"
                                        class="p-1.5 text-surface-400 hover:text-surface-600 dark:hover:text-surface-300 hover:bg-surface-100 dark:hover:bg-surface-600 rounded-lg transition-colors">
                                    <iconify-icon icon="tabler:edit" width="14" height="14"></iconify-icon>
                                </button>
                            </div>
                            <div x-show="editingLimit === key.key_id" class="flex items-center space-x-2">
                                <input
                                        type="number"
                                        x-model="editLimitValue"
                                        @keydown.enter="saveLimit(key)"
                                        @keydown.escape="cancelEdit"
                                        min="0"
                                        step="0.01"
                                        class="w-20 px-2 py-1 text-xs border border-surface-300 dark:border-surface-600 rounded bg-white dark:bg-surface-700 text-surface-900 dark:text-surface-100">
                                <button
                                        @click="saveLimit(key)"
                                        :disabled="loading.update"
                                        class="p-1.5 text-green-600 hover:text-green-700 transition-colors">
                                    <iconify-icon icon="tabler:check" width="14" height="14"></iconify-icon>
                                </button>
                                <button
                                        @click="cancelEdit"
                                        class="p-1.5 text-red-500 hover:text-red-600 transition-colors">
                                    <iconify-icon icon="tabler:x" width="14" height="14"></iconify-icon>
                                </button>
                            </div>
                        </td>

                        <!-- Balance -->
                        <td class="px-6 py-4 whitespace-nowrap">
                            <div class="flex items-center space-x-2">
                                <div x-show="!loading.balance[key.key_id] && !key.balance" class="text-sm text-surface-500 dark:text-surface-400">
                                    Not checked
                                </div>
                                <div x-show="loading.balance[key.key_id]" class="flex items-center text-sm text-surface-600 dark:text-surface-400">
                                    <iconify-icon icon="tabler:loader-2" class="animate-spin mr-1" width="14" height="14"></iconify-icon>
                                    Checking...
                                </div>
                                <div x-show="!loading.balance[key.key_id] && key.balance" class="flex items-center space-x-2">
                                    <span class="text-sm font-medium" :class="getBalanceColorClass(key.balance)" x-text="formatBalance(key.balance)"></span>
                                    <div class="w-2 h-2 rounded-full" :class="getBalanceIndicatorClass(key.balance)"></div>
                                </div>
                                <button
                                        @click="checkBalance(key)"
                                        :disabled="loading.balance[key.key_id]"
                                        class="p-1.5 text-surface-400 hover:text-green-600 dark:hover:text-green-400 hover:bg-surface-100 dark:hover:bg-surface-600 rounded-lg transition-colors disabled:opacity-50">
                                    <iconify-icon icon="tabler:refresh" width="14" height="14"></iconify-icon>
                                </button>
                            </div>
                        </td>

                        <!-- Status -->
                        <td class="px-6 py-4 whitespace-nowrap">
                            <span class="inline-flex items-center px-2.5 py-1 rounded-full text-xs font-medium" :class="getStatusClass(key)">
                                <span x-text="getStatusText(key)"></span>
                            </span>
                        </td>

                        <!-- Created Date -->
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-surface-500 dark:text-surface-400" x-text="formatDate(key.created_at)"></td>

                        <!-- Actions -->
                        <td class="px-6 py-4 whitespace-nowrap">
                            <div class="flex items-center space-x-2">
                                <!-- Toggle Enable/Disable -->
                                <button
                                        @click="toggleKeyStatus(key)"
                                        :disabled="loading.toggle"
                                        :class="key.is_disabled ? 'text-green-600 hover:text-green-700' : 'text-amber-600 hover:text-amber-700'"
                                        class="p-1.5 hover:bg-surface-100 dark:hover:bg-surface-600 rounded-lg transition-colors"
                                        :title="key.is_disabled ? 'Enable key' : 'Disable key'">
                                    <iconify-icon x-show="!key.is_disabled" icon="tabler:power" width="14" height="14"></iconify-icon>
                                    <iconify-icon x-show="key.is_disabled" icon="tabler:player-play" width="14" height="14"></iconify-icon>
                                </button>

                                <!-- Delete -->
                                <button
                                        @click="deleteKey(key)"
                                        class="p-1.5 text-red-500 hover:text-red-700 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition-colors">
                                    <iconify-icon icon="tabler:trash" width="14" height="14"></iconify-icon>
                                </button>
                            </div>
                        </td>
                    </tr>
                </template>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Status Messages -->
    <div x-show="notification.show" x-transition:enter="transform ease-out duration-300 transition" x-transition:enter-start="translate-y-full opacity-0" x-transition:enter-end="translate-y-0 opacity-100" x-transition:leave="transition ease-in duration-300" x-transition:leave-start="translate-y-0 opacity-100" x-transition:leave-end="translate-y-full opacity-0" class="fixed bottom-4 right-4 max-w-md z-50">
        <div class="flex items-center p-4 rounded-xl shadow-lg border" :class="{
            'bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800': notification.type === 'success',
            'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800': notification.type === 'error',
            'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800': notification.type === 'info'
        }">
            <div class="flex-shrink-0 mr-3">
                <template x-if="notification.type === 'success'">
                    <iconify-icon icon="tabler:check-circle" class="h-6 w-6 text-green-600 dark:text-green-400" width="24" height="24"></iconify-icon>
                </template>
                <template x-if="notification.type === 'error'">
                    <iconify-icon icon="tabler:alert-circle" class="h-6 w-6 text-red-600 dark:text-red-400" width="24" height="24"></iconify-icon>
                </template>
                <template x-if="notification.type === 'info'">
                    <iconify-icon icon="tabler:info-circle" class="h-6 w-6 text-blue-600 dark:text-blue-400" width="24" height="24"></iconify-icon>
                </template>
            </div>
            <div class="flex-1">
                <p class="text-sm font-medium" :class="{
                    'text-green-800 dark:text-green-100': notification.type === 'success',
                    'text-red-800 dark:text-red-100': notification.type === 'error',
                    'text-blue-800 dark:text-blue-100': notification.type === 'info'
                }" x-text="notification.message"></p>
            </div>
            <div class="flex-shrink-0 ml-3">
                <button @click="hideNotification()" class="inline-flex text-surface-400 hover:text-surface-600 focus:outline-none transition-colors duration-200">
                    <iconify-icon icon="tabler:x" class="h-5 w-5" width="20" height="20"></iconify-icon>
                </button>
            </div>
        </div>
    </div>
</div>

<script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('openRouterApp', () => ({
            // State
            keys: [],
            wippyApi: null,

            // Form
            form: {
                emails: '',
                creditLimit: 10.00
            },

            // Loading states
            loading: {
                list: false,
                create: false,
                update: false,
                delete: false,
                toggle: false,
                balance: {},
                balanceAll: false
            },

            // Edit state
            editingLimit: null,
            editLimitValue: '',

            // Notification
            notification: {
                show: false,
                type: 'success',
                message: '',
                timeout: null
            },

            // Balance throttling
            balanceThrottle: {
                lastCall: 0,
                delay: 1000 // 1 second between calls
            },

            // Computed
            get emailCount() {
                if (!this.form.emails.trim()) return 0;
                return this.form.emails.trim().split('\n').filter(email => email.trim().length > 0).length;
            },

            get canCreate() {
                return this.emailCount > 0 && this.form.creditLimit > 0;
            },

            // Lifecycle
            async init() {
                try {
                    this.wippyApi = await window.initWippyApi();
                    await this.loadKeys();
                } catch (error) {
                    console.error('Failed to initialize:', error);
                    this.showNotification('error', 'Failed to initialize application');
                }
            },

            // Load keys
            async loadKeys() {
                this.loading.list = true;
                try {
                    const response = await this.wippyApi.api.get('/api/v1/openrouter/keys');

                    if (response.data && response.data.success) {
                        this.keys = response.data.keys || [];
                        // Initialize balance loading states
                        this.keys.forEach(key => {
                            this.loading.balance[key.key_id] = false;
                        });
                    } else {
                        throw new Error(response.data?.error || 'Failed to load keys');
                    }
                } catch (error) {
                    console.error('Load keys error:', error);
                    this.showNotification('error', 'Failed to load keys: ' + error.message);
                    this.keys = [];
                } finally {
                    this.loading.list = false;
                }
            },

            // Create keys
            async createKeys() {
                if (!this.canCreate) return;

                this.loading.create = true;
                try {
                    const emails = this.form.emails.trim().split('\n')
                        .map(email => email.trim())
                        .filter(email => email.length > 0);

                    const response = await this.wippyApi.api.post('/api/v1/openrouter/keys', {
                        emails: emails,
                        credit_limit: parseFloat(this.form.creditLimit)
                    });

                    if (response.data && response.data.success) {
                        const successCount = response.data.successful_count || 0;
                        const failCount = response.data.failed_count || 0;

                        if (successCount > 0) {
                            this.showNotification('success', `Created ${successCount} keys successfully` + (failCount > 0 ? ` (${failCount} failed)` : ''));
                            this.form.emails = '';
                            this.form.creditLimit = 10.00;
                            await this.loadKeys();
                        } else {
                            this.showNotification('error', 'No keys were created successfully');
                        }
                    } else {
                        throw new Error(response.data?.error || 'Failed to create keys');
                    }
                } catch (error) {
                    console.error('Create keys error:', error);
                    this.showNotification('error', 'Failed to create keys: ' + error.message);
                } finally {
                    this.loading.create = false;
                }
            },

            // Balance checking
            async checkBalance(key) {
                if (this.loading.balance[key.key_id]) return;

                // Throttle individual checks
                const now = Date.now();
                if (now - this.balanceThrottle.lastCall < this.balanceThrottle.delay) {
                    this.showNotification('info', 'Please wait before checking another balance');
                    return;
                }
                this.balanceThrottle.lastCall = now;

                this.loading.balance[key.key_id] = true;
                try {
                    const response = await this.wippyApi.api.get(`/api/v1/openrouter/keys/${key.key_id}/balance`);

                    if (response.data && response.data.success) {
                        const keyIndex = this.keys.findIndex(k => k.key_id === key.key_id);
                        if (keyIndex >= 0) {
                            this.keys[keyIndex].balance = response.data.balance;
                            this.keys[keyIndex].balanceCheckedAt = new Date().toISOString();
                        }
                    } else {
                        throw new Error(response.data?.error || 'Failed to check balance');
                    }
                } catch (error) {
                    console.error('Check balance error:', error);
                    this.showNotification('error', 'Failed to check balance: ' + error.message);
                } finally {
                    this.loading.balance[key.key_id] = false;
                }
            },

            async checkAllBalances() {
                if (this.loading.balanceAll || this.keys.length === 0) return;

                this.loading.balanceAll = true;
                let checkedCount = 0;
                let errorCount = 0;

                try {
                    for (const key of this.keys) {
                        if (key.is_disabled) continue; // Skip disabled keys

                        this.loading.balance[key.key_id] = true;

                        try {
                            const response = await this.wippyApi.api.get(`/api/v1/openrouter/keys/${key.key_id}/balance`);

                            if (response.data && response.data.success) {
                                const keyIndex = this.keys.findIndex(k => k.key_id === key.key_id);
                                if (keyIndex >= 0) {
                                    this.keys[keyIndex].balance = response.data.balance;
                                    this.keys[keyIndex].balanceCheckedAt = new Date().toISOString();
                                }
                                checkedCount++;
                            } else {
                                errorCount++;
                            }
                        } catch (error) {
                            console.error(`Balance check failed for ${key.email}:`, error);
                            errorCount++;
                        } finally {
                            this.loading.balance[key.key_id] = false;
                        }

                        // Throttle between requests
                        if (this.keys.indexOf(key) < this.keys.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                    }

                    const message = `Checked ${checkedCount} balances` + (errorCount > 0 ? ` (${errorCount} failed)` : '');
                    this.showNotification(errorCount === 0 ? 'success' : 'info', message);
                } catch (error) {
                    console.error('Check all balances error:', error);
                    this.showNotification('error', 'Failed to check balances: ' + error.message);
                } finally {
                    this.loading.balanceAll = false;
                }
            },

            // Toggle key status (enable/disable)
            async toggleKeyStatus(key) {
                this.loading.toggle = true;
                try {
                    const newDisabledState = !key.is_disabled;
                    const response = await this.wippyApi.api.patch(`/api/v1/openrouter/keys/${key.key_id}/disable`, {
                        disabled: newDisabledState
                    });

                    if (response.data && response.data.success) {
                        const keyIndex = this.keys.findIndex(k => k.key_id === key.key_id);
                        if (keyIndex >= 0) {
                            this.keys[keyIndex].is_disabled = newDisabledState;
                        }
                        this.showNotification('success', `Key ${newDisabledState ? 'disabled' : 'enabled'} successfully`);
                    } else {
                        throw new Error(response.data?.error || 'Failed to toggle key status');
                    }
                } catch (error) {
                    console.error('Toggle key status error:', error);
                    this.showNotification('error', 'Failed to toggle key status: ' + error.message);
                } finally {
                    this.loading.toggle = false;
                }
            },

            // Edit limit
            startEditLimit(key) {
                this.editingLimit = key.key_id;
                this.editLimitValue = parseFloat(key.credit_limit);
            },

            cancelEdit() {
                this.editingLimit = null;
                this.editLimitValue = '';
            },

            async saveLimit(key) {
                if (this.loading.update) return;

                this.loading.update = true;
                try {
                    const newLimit = parseFloat(this.editLimitValue);
                    if (isNaN(newLimit) || newLimit < 0) {
                        throw new Error('Invalid credit limit');
                    }

                    const response = await this.wippyApi.api.put(`/api/v1/openrouter/keys/${key.key_id}/limit`, {
                        credit_limit: newLimit
                    });

                    if (response.data && response.data.success) {
                        const keyIndex = this.keys.findIndex(k => k.key_id === key.key_id);
                        if (keyIndex >= 0) {
                            this.keys[keyIndex].credit_limit = newLimit;
                        }
                        this.showNotification('success', 'Credit limit updated successfully');
                        this.cancelEdit();
                    } else {
                        throw new Error(response.data?.error || 'Failed to update credit limit');
                    }
                } catch (error) {
                    console.error('Update limit error:', error);
                    this.showNotification('error', 'Failed to update limit: ' + error.message);
                } finally {
                    this.loading.update = false;
                }
            },

            // Delete key with 404 handling
            async deleteKey(key) {
                try {
                    const confirmed = await this.wippyApi.iframe.confirm({
                        message: `Delete API key for "${key.email}"? This cannot be undone.`,
                        header: 'Confirm Deletion',
                        acceptLabel: 'Delete',
                        rejectLabel: 'Cancel'
                    });

                    if (!confirmed) return;

                    try {
                        const response = await this.wippyApi.api.delete(`/api/v1/openrouter/keys/${key.key_id}`);

                        if (response.data && response.data.success) {
                            this.keys = this.keys.filter(k => k.key_id !== key.key_id);
                            delete this.loading.balance[key.key_id];
                            this.showNotification('success', 'API key deleted successfully');
                        } else {
                            throw new Error(response.data?.error || 'Failed to delete key');
                        }
                    } catch (error) {
                        // Handle 404 or other errors gracefully
                        if (error.response && error.response.status === 404) {
                            // Key not found on server, remove from local list
                            this.keys = this.keys.filter(k => k.key_id !== key.key_id);
                            delete this.loading.balance[key.key_id];
                            this.showNotification('success', 'API key removed (was already deleted from server)');
                        } else {
                            throw error;
                        }
                    }
                } catch (error) {
                    console.error('Delete key error:', error);
                    this.showNotification('error', 'Failed to delete key: ' + error.message);
                }
            },

            // Key display utilities
            formatKeyDisplay(keyValue) {
                if (!keyValue) return '';
                return keyValue.substring(0, 8) + '...' + keyValue.substring(keyValue.length - 8);
            },

            // Status utilities
            getStatusClass(key) {
                if (key.is_disabled) {
                    return 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-300';
                } else if (key.is_active) {
                    return 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300';
                } else {
                    return 'bg-surface-100 text-surface-800 dark:bg-surface-700 dark:text-surface-300';
                }
            },

            getStatusText(key) {
                if (key.is_disabled) {
                    return 'Disabled';
                } else if (key.is_active) {
                    return 'Active';
                } else {
                    return 'Inactive';
                }
            },

            // Balance utilities - FIXED to handle OpenRouter API response structure
            formatBalance(balance) {
                if (!balance) return 'Unknown';
                if (balance.error) return 'Error';

                // Handle nested data structure from OpenRouter API
                let balanceData = balance;
                if (balance.data) {
                    balanceData = balance.data;
                }

                // Check for OpenRouter's structure: usage and limit
                if (balanceData.usage !== undefined && balanceData.limit !== undefined) {
                    const remaining = balanceData.limit - balanceData.usage;
                    return `$${remaining.toFixed(2)} left`;
                }
                // Check for limit_remaining field (which OpenRouter also provides)
                else if (balanceData.limit_remaining !== undefined) {
                    return `$${balanceData.limit_remaining.toFixed(2)} left`;
                }
                // Check for credits field (alternative format)
                else if (balanceData.credits !== undefined) {
                    return `$${balanceData.credits.toFixed(2)}`;
                }

                return 'Unknown format';
            },

            getBalanceColorClass(balance) {
                if (!balance || balance.error) return 'text-surface-600 dark:text-surface-400';

                // Handle nested data structure
                let balanceData = balance;
                if (balance.data) {
                    balanceData = balance.data;
                }

                let remaining = 0;
                if (balanceData.usage !== undefined && balanceData.limit !== undefined) {
                    remaining = balanceData.limit - balanceData.usage;
                } else if (balanceData.limit_remaining !== undefined) {
                    remaining = balanceData.limit_remaining;
                } else if (balanceData.credits !== undefined) {
                    remaining = balanceData.credits;
                }

                if (remaining <= 0) return 'text-red-600 dark:text-red-400';
                if (remaining < 5) return 'text-amber-600 dark:text-amber-400';
                if (remaining < 20) return 'text-yellow-600 dark:text-yellow-400';
                return 'text-green-600 dark:text-green-400';
            },

            getBalanceIndicatorClass(balance) {
                if (!balance || balance.error) return 'bg-surface-300 dark:bg-surface-600';

                // Handle nested data structure
                let balanceData = balance;
                if (balance.data) {
                    balanceData = balance.data;
                }

                let remaining = 0;
                if (balanceData.usage !== undefined && balanceData.limit !== undefined) {
                    remaining = balanceData.limit - balanceData.usage;
                } else if (balanceData.limit_remaining !== undefined) {
                    remaining = balanceData.limit_remaining;
                } else if (balanceData.credits !== undefined) {
                    remaining = balanceData.credits;
                }

                if (remaining <= 0) return 'bg-red-500';
                if (remaining < 5) return 'bg-amber-500';
                if (remaining < 20) return 'bg-yellow-500';
                return 'bg-green-500';
            },

            // Utilities
            async copyToClipboard(text) {
                try {
                    await navigator.clipboard.writeText(text);
                    this.showNotification('success', 'API key copied to clipboard');
                } catch (error) {
                    console.error('Copy error:', error);
                    this.showNotification('error', 'Failed to copy to clipboard');
                }
            },

            formatDate(dateString) {
                if (!dateString) return 'N/A';
                // Handle Unix timestamp (number) or ISO string
                const date = typeof dateString === 'number' ? new Date(dateString * 1000) : new Date(dateString);
                return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
            },

            exportCSV() {
                if (this.keys.length === 0) {
                    this.showNotification('error', 'No keys to export');
                    return;
                }

                try {
                    const headers = ['Email', 'API Key', 'Credit Limit', 'Balance', 'Status', 'Created Date'];
                    const csvContent = [
                        headers.join(','),
                        ...this.keys.map(key => [
                            `"${key.email}"`,
                            `"${key.key_value}"`,
                            `"${parseFloat(key.credit_limit).toFixed(2)}"`,
                            `"${this.formatBalance(key.balance)}"`,
                            `"${this.getStatusText(key)}"`,
                            `"${this.formatDate(key.created_at)}"`
                        ].join(','))
                    ].join('\n');

                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    link.setAttribute('download', `openrouter-keys-${new Date().toISOString().split('T')[0]}.csv`);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    this.showNotification('success', 'CSV exported successfully');
                } catch (error) {
                    console.error('Export error:', error);
                    this.showNotification('error', 'Failed to export CSV');
                }
            },

            // Notifications
            showNotification(type, message, duration = 5000) {
                if (this.notification.timeout) {
                    clearTimeout(this.notification.timeout);
                }

                this.notification.type = type;
                this.notification.message = message;
                this.notification.show = true;

                this.notification.timeout = setTimeout(() => {
                    this.hideNotification();
                }, duration);
            },

            hideNotification() {
                this.notification.show = false;
                if (this.notification.timeout) {
                    clearTimeout(this.notification.timeout);
                    this.notification.timeout = null;
                }
            }
        }));
    });
</script>
{{ end }}
